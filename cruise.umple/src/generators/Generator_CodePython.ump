/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

*/

namespace cruise.umple.compiler;
class PythonGenerator
{
  isA JavaGenerator;
  depend java.io.*;
  depend java.nio.file.*;  
  depend cruise.umple.compiler.java.*;
  depend cruise.umple.util.StringFormatter;
  depend cruise.umple.compiler.exceptions.*;
  
  private static final int TXL_VERSION = 4;
  
  @Override  
  public void writeFile(UmpleElement aClass) throws IOException
  {
    if (!isTxlInstalled()) {
      throw new UmpleCompilerException("TXL is required for Python code generation. Please go to https://www.txl.ca/txl-download.html to download and install TXL.", new IOException("TXL not found"));
    } 
    
    //System.out.println("toString() methods have been removed due to an issue with their generation.");
    String className=aClass.getName();
    UmpleClass uClass;
    if (aClass instanceof UmpleClass)
    { 
      uClass=(UmpleClass)aClass; 
      if(uClass.getHasProxyPattern()||(uClass.getIsDistributed()&&(getModel().getDistributePattern()==1||getModel().getDistributePattern()==2)))
      {
        aClass.setName(className+"Impl");
          }
      if(uClass.hasOuterClass())
      {
        return ; // inner classes should not be writen in single files.
      }
    }
    ILang language = getLanguageFor(aClass);
    String contents = language.getCode(getModel(), aClass);

    aClass.setName(className);
    String path = StringFormatter.addPathOrAbsolute( 
                  getModel().getUmpleFile().getPath(), 
                            getOutput()) + 
                            aClass.getPackageName().replace(".", File.separator);  
    if (aClass instanceof UmpleClass)
    { uClass=(UmpleClass)aClass;
      if(uClass.getNeedsDefaultInterface()||uClass.getIsDistributed()||uClass.getHasProxyPattern()){
        contents= super.WriteProxyFiles(contents,uClass,path);
      }    
      if(uClass.getHasProxyPattern()||(uClass.getIsDistributed()&&(getModel().getDistributePattern()==1||getModel().getDistributePattern()==2))){
        className=className+"Impl";
        //contents=contents.replaceAll("(,|, |\\(|\\( )(this)(,| ,|\\)| \\))","$1self$3");
      }        
    }
    
    File file = new File(path);
    file.mkdirs();   
    String filename = path + File.separator + className + ".java";
    BufferedWriter bw = new BufferedWriter(new FileWriter(filename));

    try
    {
      bw.write(contents);
      bw.flush();
    }
    finally
    {
      bw.close();
      contents = "";
    }
    
    generateTxlFiles();
    
    String pythonFilename = path + File.separator + className + ".py";
    String TXLScriptsPath = "./txl/umpleJavaToPython.txl";
    String[] TXLcommand = {"txl", filename, TXLScriptsPath, "-o", pythonFilename};
    
    try {
            
      Process p = Runtime.getRuntime().exec(TXLcommand);
      BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));

      String line;
      if(reader.ready()) {
        line = reader.readLine();
      }
      else {
        line = null;
      }

      while (line!=null) {
        if(line.contains("error")) { 
           System.err.println("TXL ran into an error while processing one of the files. The file may be missing from the generated code.");
           return;
        }

        if(reader.ready()) {
          line = reader.readLine();
        }
        else {
          line = null;
        }
      }

      p.waitFor();

    } catch (IOException e) {
      System.err.println(e.getMessage());
	  throw new UmpleCompilerException("Unable to open Runtime Process.", e);
    } catch (InterruptedException e) {
      System.err.println(e.getMessage());
      throw new UmpleCompilerException("Unable to open Runtime Process.", e);
    } catch (Exception e) {
      throw new UmpleCompilerException("Unable to open Runtime Process.", e);    
    }

    try {
      File pythonFile = new File(pythonFilename);
      Scanner pyReader = new Scanner(pythonFile);
      while (pyReader.hasNextLine()) {
        contents += pyReader.nextLine() + "\n";
      }
      pyReader.close();
    } catch (FileNotFoundException e) {
      System.err.println("Error found with compilation of " + new File(pythonFilename).getName() + " : Output might be missing a file");
      return;
    }

    getModel().getGeneratedCode().put(aClass.getName(),contents);
    
    /* TODO
    if (aClass instanceof UmpleClass)
    {
      StringBuilder exceptionBuilder = new StringBuilder();
      for(String key:((JavaClassGenerator)language).uncaughtExceptions.keySet())
      {
        exceptionBuilder.append(((JavaClassGenerator)language).uncaughtExceptions.get(key).toString()+System.getProperty("line.separator"));
      }
      String exception = exceptionBuilder.toString();
      uncaughtExceptions.append(exception);
      if(((UmpleClass)aClass).getHasMainMethod())
      {
        mainClasses.add((UmpleClass)aClass);
      }
    } */
  }  
  
  private boolean isTxlInstalled()
  {
    //Check for TXL installation 
	try {
        
  	  Process p = Runtime.getRuntime().exec("txl");    
	  BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
	
	  String line;
	  if(reader.ready()) {
	    line = reader.readLine();
	  }
	  else {
	    line = null;
	  }
	
	  while (line!=null) {
	    if(!line.startsWith("TXL v")) {
	      throw new IOException("TXL not found.");
	    }
	
	    if(reader.ready()) {
	      line = reader.readLine();
	    }
	    else {
	      line = null;
	    }
	  }
	} catch (IOException e) {
	  System.err.println(e.getMessage());
	  System.err.println("TXL is required for Python code generation. Please go to https://www.txl.ca/txl-download.html to download and install TXL.");
	  return false;
	} catch (Exception e) {
	  throw new UmpleCompilerException("Unable to open Runtime Process.", e);
	}
	return true;
  }
    
  private void generateTxlFiles() throws IOException {

    boolean regenerateFiles = false;

    try {
        //Look for TXL folder
        Path tempDir = Paths.get("txl");

        if (Files.exists(tempDir)) {

            //Check last update time 
            Path tempVersion = Paths.get("txl/TXL-Version.txt");
            if (Files.exists(tempVersion)) {
                File versionFile = new File("txl/TXL-Version.txt");
                Scanner myReader = new Scanner(versionFile);
                
                if (myReader.hasNextLine()) {
                  String version = myReader.nextLine();

                    if (!version.equals(Integer.toString(TXL_VERSION))) {
                        regenerateFiles = true;
                    } 
                } else {
                	regenerateFiles = true;
                }

                myReader.close();
            } else {
				      regenerateFiles = true;
            }

            // If version number is valid, verify file integrity
            if (!regenerateFiles) {
                Path tempJavaGrm = Paths.get("txl/Java.Grm");
                Path tempPythonGrm = Paths.get("txl/Python.Grm");
                Path tempTxl = Paths.get("txl/umpleJavaToPython.txl");

                if (!Files.exists(tempJavaGrm)) regenerateFiles = true;
                if (!Files.exists(tempPythonGrm)) regenerateFiles = true;
                if (!Files.exists(tempTxl)) regenerateFiles = true;
            }

        } else {
            regenerateFiles = true;
        }
    } catch (Exception e) {
        throw new UmpleCompilerException("An error occured while verifying the integrity of the Txl files.", e);
    }

    if (regenerateFiles) {
    	String versionPath = "txl/TXL-Version.txt";
    	String javaGrmPath = "txl/Java.Grm";
    	String pythonGrmPath = "txl/Python.Grm";
    	String txlTransPath = "txl/umpleJavaToPython.txl";
    	
		  String versionContent = Integer.toString(TXL_VERSION) + "\nThese files were automatically generated by Umple for the python code generation and can be safely deleted after the generation.";
      String javaGrmContent = "comments\n    //\n    /*  */\nend comments\n\ncompounds \n    'self. '== '!=\nend compounds \n\ntokens\n    number  \"(-\\s?)?\\d+(.\\d+)?\"\n    garbage \"toString(#})*}\"\nend tokens\n\n%--------------------%\n%     Statements     %\n%--------------------%\n\nkeys\n return new if else for true false while this super self tuple len True False + - * / ? ; : toString\nend keys\n\ndefine acess_modifier\n        'private\n    |   'public\n    |   'protected\nend define\n\ndefine boolean_operator\n        '&&\n    |   '|'|\nend define\n\ndefine comparator\n        '==\n    |   '!=\n    |   '>\n    |   '<\n    |   '>=\n    |   '<=\nend define\n\ndefine arithmatic_operator\n        '+\n    |   '-\n    |   '*\n    |   '/\n    |   '%\nend define\n\ndefine program\n    [repeat package_statement]  \n    [repeat import_statement]\n    [repeat class_declaration]\nend define\n\ndefine package_statement \n    'package [imported]';\nend define\n\ndefine import_statement \n    'import [imported]';\nend define\n\n\n\ndefine imported\n        [id]\n    |   '*\n    |   [id]'. [imported]\nend define\n\ndefine class_name\n    [id]'< [list id] '>\n    | [id]   \nend define\n\ndefine arithmatic_expression\n       [value_no_recursion] [arithmatic_operator] [arithmatic_expression]\n    |   [value_no_recursion]\nend define\n\ndefine nested_identifier\n        [nestable_value] [repeat attribute_access]\nend define\n\ndefine attribute_access\n       '. [nestable_value] \nend define\n\ndefine nestable_value \n        [function_call]\n    |    [id]\n    |   'this\n    |   'super\nend define\n\ndefine value_no_recursion \n        [new_call]\n    |   '( [value]')\n    |   [nested_identifier]\n    |   [number]\n    |   [stringlit]\n    |   'null\n    |   'true\n    |   'false\n    |   [casting]\n    |   '! [boolean_expression]\nend define\n\ndefine value\n       [value_no_ternary]\nend define\n\ndefine value_no_ternary\n        [value_no_recursion]\n    |   [boolean_expression]\n    |   [arithmatic_expression]\nend define\n\ndefine new_call\n    'new [class_name] '( [list value] ')\nend define\n\ndefine variable_declaration\n        [class_name] [assignment] '; [NL]\n    |   [class_name] [nested_identifier]';\nend define\n\ndefine assignment\n        [nested_identifier] '= [value] \n    |    [nested_identifier]'++\n    |    [nested_identifier]'--\n    |   [nested_identifier] '+= [value]\n    |   [nested_identifier] '-= [value]\nend define\n\n\ndefine stmt_return\n        'return [value] '; [NL]\nend define\n\ndefine statement\n        [variable_declaration]\n    |   [stmt_return]\n    |   [conditional_block]\n    |   [for_loop]\n    |   [for_in_loop]\n    |   [while_loop]\n    |   [nested_identifier]'; [NL]\n    |   [assignment] '; [NL]\n    |   [throw_statement]\nend define\n\ndefine while_loop\n    'while( [value] ') [NL] '{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\n\ndefine for_loop\n    'for( [variable_declaration] [value]'; [assignment]') '{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine for_in_loop\n    'for( [class_name] [id] ': [nested_identifier]')'{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine conditional_block\n    [if] [repeat else_if] [opt else]\nend define\n\ndefine if \n    'if '( [value] ') '{  [repeat statement]  '}\nend define\n\ndefine else_if\n    'else 'if '( [value] ') [NL]'{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine else\n    'else [NL]'{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine throw_statement\n    'throw 'new [id] '( [stringlit] ');\nend define\n\ndefine casting\n    '( [class_name]') [nested_identifier]\nend define\n\ndefine function_call\n        [id][SPOFF] '( [SPON] [list value]')    \nend define\n\ndefine boolean_expression\n       [condition] [boolean_operator] [boolean_expression]\n    |  [condition]\nend define\n\ndefine condition\n        [value_no_recursion] [comparator] [value]\n    |   [value_no_recursion]\nend define\n\ndefine boolean_element\n        [value_no_recursion]\nend define\n\n\ndefine method_parameter\n    [class_name] [id]\nend define\n\ndefine concrete_method_declaration\n        [acess_modifier] [opt static] [class_name] [id] '( [list method_parameter] ') [NL] '{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine method_declaration\n        [concrete_method_declaration]\n    |   [abstract_method_declaration]\n    |   [toString_method_garbage]\nend define\n\ndefine toString_method_garbage\n    [acess_modifier] [opt static] [class_name] [garbage]\n    |   [empty]\nend define\n\ndefine abstract_method_declaration\n    [acess_modifier] [class_name] [id] '( [list method_parameter] '); [NL]\nend define\n\ndefine inheritance_statement\n        'extends\n    |   'implements\nend define\n\n\n%--------------------%\n%        Class       %\n%--------------------%\n\ndefine class_declaration\n        [concrete_class_declaration]\n    |   [interface_declaration]\nend define\n\ndefine concrete_class_declaration\n    [acess_modifier] 'class [class_name] [repeat inheritance_list] [NL] '{ [NL] [IN] [class_body_decl] [EX] '} [NL]\nend define\n\ndefine inheritance_list\n    [inheritance_statement] [list class_name]\nend define\n\ndefine interface_declaration\n        [acess_modifier] 'interface [class_name] [repeat inheritance_list] [NL] '{ [NL] [IN] [class_body_decl] [EX] '} [NL]\nend define\n\ndefine class_type\n        'class\n    |   'interface\nend define\n\ndefine static\n    'static\nend define\n\ndefine volatile\n    'volatile\nend define\n\ndefine constructor\n    [acess_modifier] [id]'( [list method_parameter] ') [NL] '{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine member_variable_declaration\n    [opt acess_modifier] [opt static] [opt volatile] [variable_declaration]\nend define\n\ndefine class_body_decl\n    [repeat member_variable_declaration] [opt constructor] [repeat method_declaration]\nend define\n\n";
      String pythonGrmContent = "include \"Java.Grm\"\n\nredefine boolean_operator\n    ...\n    |'and\n    | 'or\nend redefine\n\nredefine comparator\n    ...\n    |   'is\n    |   'in\nend redefine\n\nredefine nestable_value\n    ...\n    | 'self\n    |  [array_access]\nend redefine\n\n\ndefine array_access\n    [id] [SPOFF] '[ [value] '] [SPON]\nend define\n\nredefine assignment\n    ...\n    |   [nested_identifier] '= [value] [NL]\nend redefine\n\nredefine statement\n    ...\n    |  [nested_identifier] [NL]\n    | 'pass\nend redefine\n\nredefine stmt_return\n    ...\n    |   'return [value] [NL]\nend redefine\n\n\nredefine value_no_recursion\n    ...\n    |   'True\n    |   'False\n    |   'None\n    |   '[ [list value] ']\n    |   'not [boolean_expression] \nend redefine\n\ndefine python_function_name\n        'tuple\n    |   'len\n    |   'super\nend define\n\nredefine function_call\n    ...\n    |   [python_function_name] [SPOFF] '( [SPON] [list value]')\nend redefine\n\n\nredefine for_loop\n    ...\n    |'for [nestable_value] 'in 'range( [value] ', [value] ', [value] '): [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine for_in_loop\n    ...\n    | 'for [id] 'in  [nested_identifier] [SPOFF] ': [SPON] [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine while_loop\n    ...\n    | [opt variable_declaration] 'while [value] ': [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine if \n    ... \n    |   'if [value] ': [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine else_if\n    ...\n    |   'elif [value] ': [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine else\n    ...\n    |   'else:  [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine throw_statement\n    ...\n    |   'raise 'RuntimeError( [stringlit] ') [NL]\nend redefine\n\n\nredefine method_parameter\n    ...\n    | [id]\nend redefine\n\ndefine decorator\n    '@ [SPOFF] [id] [SPON] [NL]\nend define\n\nredefine concrete_method_declaration\n    ...\n    |   [opt decorator] 'def  [id] [SPOFF]'(self, [SPON] [list id] [SPOFF] '): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\n    |   [opt decorator] 'def  [id] [SPOFF]'(self): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\n    |   [opt decorator] 'def  [id] [SPOFF]'(): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\nend redefine\n\nredefine abstract_method_declaration\n    ...\n    |   [SPOFF] '@abstractmethod [SPON] [NL] 'def  [id] [SPOFF]'(self, [SPON] [list id] [SPOFF] '): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\n    |   [SPOFF] '@abstractmethod [SPON] [NL] 'def  [id] [SPOFF]'(self): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\nend redefine\n\n\nredefine constructor\n    ...\n    | 'def '__init__ [SPOFF] '(self, [SPON] [list id] [SPOFF]'): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\n    | 'def '__init__ [SPOFF] '(self): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\nend redefine\n\nredefine concrete_class_declaration\n    ... \n    | [repeat import_statement] [NL] 'class [class_name] [SPOFF] [opt inheritance_group] ': [SPON] [NL] [IN] [class_body_decl] [NL] [EX] [NL]\nend redefine\n\ndefine inheritance_group\n    '( [SPON] [list class_name] [SPOFF] ')\nend define\n\nredefine interface_declaration\n    ... \n    |  [import_statement] [NL] 'class [class_name] [SPOFF] '(ABC): [SPON] [NL] [IN] [class_body_decl] [NL] [EX] [NL]\n    |  [import_statement] [repeat import_statement] [NL] 'class [class_name] [SPOFF] '(ABC, [SPON] [list class_name] [SPOFF] '): [SPON] [NL] [IN] [class_body_decl] [NL] [EX] [NL]\nend redefine\n\nredefine class_body_decl\n    ...\n    | 'pass\n    | [opt constructor] [repeat method_declaration]\nend redefine\n\nredefine variable_declaration\n    ...\n    |   [assignment] [FL]\n    |   [id] [FL]\nend redefine\n\nredefine import_statement\n    ...\n    |   'from [class_name] 'import [class_name] [NL]\n    |   'from [class_name] 'import [list class_name] [NL]\nend redefine \n";
      String umpleJavaToPythonTxlContent = "include \"Python.Grm\"\n\n\n%--------------------%\n%     Top level      %\n%--------------------%\nfunction main\n    replace [program] \n\t _[repeat package_statement] \n     _[repeat import_statement]\n     Classes [repeat class_declaration]\n    by\n\tClasses\n        [replaceConcreteClassesWithInheritance] \n        [replaceConcreteClassesNoInheritance]\n        [replaceInterfacesWithInheritance]\n        [replaceInterfacesNoInheritance] \n        \nend function\n\nfunction getClassesToImport declaration [member_variable_declaration]\n    replace [repeat id]\n        empty [repeat id]\n    deconstruct declaration\n        _[opt acess_modifier] _[opt static] _[opt volatile] varDec [variable_declaration]\n    deconstruct varDec\n        class [class_name] _ [id]';\n    construct classesToImport [repeat id]\n        _ [extractListClass class] [extractRegularClass class]\n    by \n        empty [addToRepeatIfNotThere each classesToImport] \nend function \n\nfunction concatenateRepeatNoDuplicates elems [repeat id]\n    replace [repeat id]\n        currentList [repeat id]\n    by\n        currentList [addToRepeatIfNotThere each elems] \nend function\n\nfunction addToRepeatIfNotThere elem [id]\n    replace [repeat id]\n        currentList [repeat id]\n    where not \n        currentList [contains elem]\n    by\n        currentList [. elem]\nend function\n\nfunction extractListClass class [class_name]\n    replace [repeat id]\n        empty [repeat id]\n    deconstruct class\n        _ [id]'< ids [list id] '>\n    construct unfiltered [repeat id]\n        _ [listToRepeat ids] \n    construct filtered [repeat id]\n        _ [filterOutDefaultTypes unfiltered]\n    by\n        filtered\nend function\n\nfunction filterOutDefaultTypes ids [repeat id]\n    replace [repeat id]\n        empty [repeat id]\n    by \n        empty [addIfNotDefaultType each ids]\nend function\n\nfunction addIfNotDefaultType id [id]\n    replace [repeat id]\n        current [repeat id]\n    where not \n        id [matchDefaultType]\n    by\n        current [. id] \nend function\n\nrule matchDefaultType\n    match [id]\n        id [id]\n    construct defaults [repeat id]\n        'byte 'short 'int 'long 'float 'double 'boolean 'char 'String 'Array\n    where   \n        defaults [contains id]\n    \n        \nend rule\n\n\nfunction extractRegularClass class [class_name]\n    replace [repeat id]\n        empty [repeat id]\n    deconstruct class\n        id [id]\n    where not \n        id [matchDefaultType]\n    by\n        empty [. id]\nend function\n\nfunction listToRepeat anys [list id]\n    replace [repeat id]\n        aRep [repeat id]\n    by \n        aRep [addToRepeat each anys]\nend function\n\nfunction addToRepeat a [id]\n     replace [repeat id]\n        aRep [repeat id]\n    by \n        aRep [. a]\nend function\n\nfunction repeatToList aRep [repeat id]\n    replace [list id]\n        aList [list id]\n    by \n        aList [addToList each aRep]\n\nend function\n\n\nfunction addToList anys [id]\n     replace [list id]\n        aRep [list id]\n    by \n        aRep [, anys]\nend function\n%--------------------%\n%     Classes        %\n%--------------------%\nrule replaceConcreteClassesWithInheritance\n    replace $ [concrete_class_declaration]\n        _ [acess_modifier] 'class className [class_name] inheritances [repeat inheritance_list+] '{ classBody [class_body_decl] '} \n    deconstruct classBody\n        decls [repeat member_variable_declaration] _ [opt constructor] _ [repeat method_declaration]\n    construct declarationClassesToImport [repeat id]\n        _ [getClassesToImport each decls]\n    construct allClassesToImport [repeat id]\n        _ [extractInheritanceImportClasses each inheritances] [concatenateRepeatNoDuplicates declarationClassesToImport]\n    construct inheritanceClasses [list class_name]\n        _ [extractInheritanceBlockClasses each inheritances]\n    construct imports [repeat import_statement]\n        _ [addImportStatement each allClassesToImport]\n    by\n        imports 'class className '( inheritanceClasses ')':  classBody  [replaceClassBody]\nend rule\n\nrule replaceConcreteClassesNoInheritance\n    replace $ [concrete_class_declaration]\n        _ [acess_modifier] 'class className [class_name] '{ classBody [class_body_decl] '}\n    deconstruct classBody\n        decls [repeat member_variable_declaration] _ [opt constructor] _ [repeat method_declaration]\n    construct declarationClassesToImport [repeat id]\n        _ [getClassesToImport each decls] \n    construct imports [repeat import_statement]\n        _ [addImportStatement each declarationClassesToImport]\n    by\n    imports 'class className ':  classBody  [replaceClassBody]\nend rule\n\n\nfunction extractInheritanceBlockClasses inheritanceList [inheritance_list]\n    replace [list class_name]\n        classes [list class_name]\n    deconstruct inheritanceList\n        _[inheritance_statement] classesToAdd [list class_name]\n    by\n        classes [, classesToAdd] \nend function\n\nfunction extractInheritanceImportClasses inheritanceList [inheritance_list]\n    replace [repeat id]\n        classesToImport [repeat id]\n    deconstruct inheritanceList\n        _[inheritance_statement] classesToAdd [list class_name]\n    construct classIds [repeat id]\n        _ [extractListClass each classesToAdd] [extractRegularClass each classesToAdd]\n    by\n        classesToImport [. classIds] \nend function\n\n\nfunction addImportStatement a [id]\n    replace [repeat import_statement]\n        imports [repeat import_statement]\n    construct newImport [import_statement]\n        'from a 'import a\n    by\n        imports [. newImport]\nend function\n\nrule replaceInterfacesNoInheritance\n    replace [interface_declaration]\n        _ [acess_modifier] 'interface className [class_name] '{ classBody [class_body_decl] '} \n    by\n        'from 'abc 'import 'ABC, 'abstractmethod 'class className '(ABC):  classBody [replaceClassBody] [replaceInterfaceBody]\nend rule\n\nrule replaceInterfacesWithInheritance\n    replace [interface_declaration]\n        _ [acess_modifier] 'interface className [class_name] inheritances [repeat inheritance_list+] '{ classBody [class_body_decl] '} \n    construct inheritanceClasses [list class_name]\n        _ [extractInheritanceBlockClasses each inheritances]\n    construct classesToImport [repeat id]\n        _ [extractInheritanceImportClasses each inheritances]\n    construct imports [repeat import_statement]\n        _ [addImportStatement each classesToImport]\n    by\n        'from 'abc 'import 'ABC, 'abstractmethod imports 'class className '(ABC, inheritanceClasses '):  classBody [replaceClassBody] [replaceInterfaceBody]\nend rule\n\nfunction replaceInterfaceBody\n   replace [class_body_decl]\n        declarations [repeat member_variable_declaration] methods [repeat method_declaration]\n    construct memberVariables [repeat id]\n        _ [addMemberVariable each declarations]\n    construct listMemberVariables [repeat id]\n        _ [addListMemberVariable each declarations]\n    by\n        '@abstractmethod 'def '__init__(self): 'pass methods [replaceAllMethods memberVariables listMemberVariables]\nend function\n\nfunction replaceClassBody\n    replace [class_body_decl]\n        declarations [repeat member_variable_declaration] oldConstructor [constructor] methods [repeat method_declaration]\n    construct memberVariables [repeat id]\n        _ [addMemberVariable each declarations]\n    construct listMemberVariables [repeat id]\n        _ [addListMemberVariable each declarations]\n    construct newContructor [constructor]\n        oldConstructor \n            [replaceAllLists listMemberVariables]\n            [replaceAllMemberVariableNames memberVariables] \n            [replaceContructor] \n            [replaceContructorNoArgs]\n    by\n        newContructor methods [replaceAllMethods memberVariables listMemberVariables]\nend function\n\n\nfunction replaceContructor\n    replace [constructor]\n         mod [acess_modifier] className [id]'( params [list method_parameter +] ') '{ statements [repeat statement]  '}\n    construct newParams [list id]\n    by\n        'def '__init__(self, newParams [translateParams each params]'):  statements [replaceStatements]\nend function\n\nfunction replaceContructorNoArgs\n    replace [constructor]\n         mod [acess_modifier] className [id]'() '{ statements [repeat statement]  '}\n    by\n        'def '__init__(self):  statements [replaceStatements]\nend function\n\n\n%--------------------%\n%     General        %\n%--------------------%\nfunction translateParams PreviousParam [method_parameter]\n    replace [list id]\n        SequenceSoFar [list id]\n    deconstruct PreviousParam\n        _ [id] paramName [id]\n    by\n        SequenceSoFar [, paramName]\nend function\n\nfunction addListMemberVariable MemberVariable [member_variable_declaration]\n    replace [repeat id]\n        SequenceSoFar [repeat id]\n    deconstruct MemberVariable\n        _[opt acess_modifier] decl [variable_declaration]\n    deconstruct decl\n        'List '< _ [list id] '> memberName [id]';\n    by\n        SequenceSoFar [. memberName]\nend function\n\nfunction addMemberVariable MemberVariable [member_variable_declaration]\n    replace [repeat id]\n        SequenceSoFar [repeat id]\n    deconstruct MemberVariable\n        _[opt acess_modifier] decl [variable_declaration]\n    deconstruct decl\n        _ [class_name] memberName [id]';\n    by\n        SequenceSoFar [. memberName]\nend function\n\nfunction replaceAllMemberVariableNames memberVariables [repeat id]\n    replace [any]\n        any [any]\n    by \n        any \n            [replaceMemberVariableNames memberVariables] \n            [replaceMemberVariableNamesWithThis memberVariables]\n            [replaceMemberVariableNamesBrackets memberVariables]\nend function\n\nrule replaceMemberVariableNames memberVariables [repeat id]\n    replace [nested_identifier]\n         name [id] rep [repeat attribute_access]\n    where \n        memberVariables [contains name]\n    construct underscore [id]\n        '_\n    construct newName [id]\n        underscore [+ name] \n    by\n        'self '. newName rep\nend rule\n\nrule replaceMemberVariableNamesWithThis memberVariables [repeat id]\n    replace [nested_identifier]\n        'this '. name [id] rep [repeat attribute_access]\n    where \n        memberVariables [contains name]\n    construct underscore [id]\n        '_\n    by\n        'self '. underscore [+ name] rep\nend rule\n\nrule replaceMemberVariableNamesBrackets memberVariables [repeat id]\n    replace [nested_identifier]\n         name [id] '[ val [value] ']  rep [repeat attribute_access]\n    where \n        memberVariables [contains name]\n    construct underscore [id]\n        '_\n    construct newName [id]\n        underscore [+ name]\n    by\n        'self '. newName '[ val ']  rep\nend rule\n\n\nrule contains Object [id]\n    match [id]\n        Object\nend rule\n\n\n%--------------------%\n%  List replacement  %\n%--------------------%\n\nfunction replaceAllLists memberLists [repeat id]\n    replace [any]\n        any [any]\n    by \n        any\n            [replaceListAssignement memberLists]\n            [replaceListUnmutable memberLists]\n            [replaceGetListContent memberLists]\n            [replaceListGetSize memberLists]\n            [replaceListGetIndex memberLists]\n            [replaceListContains memberLists]\n            [replaceListAddAtIndex memberLists]\n            [replaceListAddNoIndex memberLists]\n            [replaceListCopy]\nend function \n\nrule replaceListAssignement memberLists [repeat id]\n    replace [assignment]\n        id [id] '= 'new 'ArrayList '< _[list id] '> '(') \n    where\n        memberLists [contains id]\n    by \n        id '= '[']\nend rule\n\nrule replaceListCopy\n    replace [assignment]\n        id [id] '= 'new 'ArrayList '< _[list id] '> '( oldList [nested_identifier]') \n    deconstruct oldList\n        val [nestable_value] rep [repeat attribute_access]\n    construct newNested [repeat attribute_access]\n        '.copy()\n    by \n        id '= val rep [. newNested]\nend rule\n\nrule replaceListUnmutable memberLists [repeat id]\n    replace [value]\n        'Collections.unmodifiableList( id [id] ')\n    where\n        memberLists [contains id]\n    by \n        'tuple( id ')\nend rule\n\n\nrule replaceGetListContent memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '. 'get( index [value] ')  rest [repeat attribute_access]\n    where\n        memberLists [contains id]\n    by \n        id '[ index '] rest \nend rule\n\nrule replaceListGetSize memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '.size()\n    where\n        memberLists [contains id]\n    by \n        'len( id ')\nend rule\n\nrule replaceListGetIndex memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '.indexOf( val [value] ')\n    where\n        memberLists [contains id]\n    by \n        id '.index( val ')\nend rule\n\nrule replaceListContains memberLists [repeat id]\n    replace [value]\n        nested [nested_identifier]\n    deconstruct nested\n        id [id]'. 'contains '( val [value_no_recursion] ')\n    where\n        memberLists [contains id]\n    by \n        val 'in id\nend rule\n\nrule replaceListAddAtIndex memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '.add( position [value] ', value [value] ')\n    where\n        memberLists [contains id]\n    by \n        id '.insert( position ', value ')\nend rule\n\nrule replaceListAddNoIndex memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '.add( value [value] ')\n    where\n        memberLists [contains id]\n    by \n        id '.append( value ')\nend rule\n\n%--------------------%\n%     Methods        %\n%--------------------%\n\nfunction replaceAllMethods memberVariables [repeat id] memberLists [repeat id]\n    replace [repeat method_declaration]\n        methods [repeat method_declaration]\n    by\n        methods \n            [removeToString_garbage]\n            [replaceAllLists memberLists]\n            [replaceAllMemberVariableNames memberVariables] \n            [replaceAbstractMethod]\n            [replaceAbstractMethodNoArgs]\n            [replaceConcreteMethod] \n            [replaceConcreteMethodNoArgs]\n            [replaceStaticMethod]\nend function\n\nrule replaceConcreteMethod\n    replace [concrete_method_declaration]\n        _[acess_modifier] _[class_name] methodName [id]'( params [list method_parameter +] ') '{ statements [repeat statement] '}\n    construct newParams [list id]\n    by\n        'def methodName '(self, newParams [translateParams each params] '):  statements [replaceStatements]\nend rule\n\nrule replaceConcreteMethodNoArgs\n    replace [concrete_method_declaration]\n        _[acess_modifier] _[class_name] methodName [id]'() '{ statements [repeat statement] '}\n    by\n        'def methodName '(self):  statements [replaceStatements]\nend rule\n\nrule replaceAbstractMethod\n    replace [abstract_method_declaration]\n        _[acess_modifier] _[class_name] methodName [id] '( params [list method_parameter +] ');\n    construct newParams [list id]\n    by\n        '@abstractmethod 'def methodName '(self, newParams [translateParams each params] '): 'pass\nend rule\n\nrule replaceAbstractMethodNoArgs\n    replace [abstract_method_declaration]\n        _[acess_modifier] _[class_name] methodName [id]'();\n    by\n        '@abstractmethod 'def methodName '(self): 'pass\nend rule\n\nrule removeToString_garbage\n    replace [toString_method_garbage]\n       _ [acess_modifier] _[opt static] _[class_name]  _[garbage]\n    by\n  \nend rule\n\nrule replaceStaticMethod\n    replace [method_declaration]\n        _[acess_modifier] _[static] _[class_name] methodName [id]'() '{ statements [repeat statement] '}\n    by\n        '@staticmethod 'def methodName'():  statements [replaceStatements]\nend rule\n\n%--------------------%\n%     Statements     %\n%--------------------%\nfunction replaceStatements\n    replace [repeat statement]\n        statements [repeat statement]\n    by \n        statements \n            [replaceForLoop]\n            [replaceForInLoop]\n            [replaceAssignmentStatement] \n            [replaceReturn] \n            [replaceNoStateMents] \n            [addSelfToOwnMethodCalls]\n            [replaceThisFunctionCall]\n            [replaceNestedStatement]\n            [replaceDecleration]\n            [replaceAllBoolean]\n            [replaceDeclerationWithAssignment]\n            [replaceIf]\n            [replaceElseIf]\n            [replaceElse]\n            [replaceWhile]\n            [replaceNull]\n            [replaceThis]\n            [replaceIncrement]\n            [replaceDecrement]\n            [replaceThrowError]\n            [replaceNewCall]\n            [replaceCasting]\n            [correctSuperInit]\n            [correctSuperFunctions]\nend function\n\n\nfunction replaceNoStateMents\n    replace [repeat statement]\n        _ [empty]\n    by \n        'pass\nend function\n\nrule replaceAssignmentStatement\n    replace [statement]\n        identifier [nested_identifier] '= val [value] '; \n    by \n        identifier '= val\nend rule\n\nrule replaceReturn\n    replace [stmt_return]\n        'return val [value] ';\n    by \n        'return val\nend rule\n\nrule addSelfToOwnMethodCalls\n    replace [nested_identifier]\n        funcName [id] '( values [list value]') rep [repeat attribute_access]\n    by\n        'self '. funcName '( values') rep\nend rule\n\nrule replaceThisFunctionCall\n    replace [nested_identifier]\n        'this. funcName [id] '( values [list value]')\n    by\n        'self '. funcName '( values')\nend rule\n\nrule replaceNestedStatement\n    replace [statement]\n        stmt [statement]\n    deconstruct stmt\n        value [nested_identifier] ';\n    by\n        value\nend rule\n\n\nrule replaceThis\n    replace [value]\n        'this\n    by \n        'self\nend rule\n\nrule replaceDeclerationWithAssignment\n    replace [variable_declaration]\n        _ [class_name] assignment [assignment] ';\n    by \n        assignment\nend rule\n\nrule replaceDecleration\n    replace [variable_declaration]\n        _[class_name] varName [id]';\n    by \n        varName\nend rule\n\nrule replaceIf\n    replace [if]\n        'if '( bool [value] ') '{ statements [repeat statement]  '}\n    by \n        'if bool ': statements\nend rule\n\nrule replaceElseIf\n    replace [else_if]\n        'else 'if '( bool [value] ') '{  statements [repeat statement]  '} \n    by \n        'elif bool ': statements\nend rule\n\n\nrule replaceElse\n    replace [else]\n        'else '{  statements [repeat statement]  '} \n    by \n        'else ': statements\nend rule\n\n\nrule replaceWhile\n    replace [while_loop]\n        'while( bool [boolean_expression] ')  '{ statements [repeat statement] '} \n    by\n        'while bool ':  statements \nend rule\n\nrule replaceNull\n    replace [value]\n        'null\n    by\n        'None\nend rule\n\n\nrule replaceDecrement\n    replace [assignment]\n        nest [nestable_value] '--\n    construct test [arithmatic_expression]\n        nest '- '1\n    by \n        nest '= test\nend rule\n\nrule replaceIncrement\n    replace [assignment]\n        nest [nestable_value] '++\n    by \n        nest '= nest '+ '1\nend rule\n\nrule replaceForLoop\n    replace [statement]\n        'for( decl [variable_declaration] goal [value]'; assignment [assignment]') '{  stmts[repeat statement]  '} \n    deconstruct decl\n        _[class_name] name [id] '= start [value] ';\n    construct declaration [variable_declaration]\n        name '= start\n    construct newStatements [repeat statement]\n        assignment\n    by \n        declaration 'while goal ':  stmts  [. newStatements]\nend rule\n\nrule replaceForInLoop\n    replace [for_in_loop]\n        'for( _[class_name] var [id] ': nested [nested_identifier]')'{ stmts [repeat statement] '} \n    by \n        'for var 'in  nested':  stmts\nend rule\n\nrule replaceThrowError\n    replace [throw_statement]\n        'throw 'new _[id] '( message [stringlit] ');\n    by\n        'raise 'RuntimeError(  message ') \nend rule \n\nrule replaceCasting\n    replace [value]\n        '( _ [class_name]') name [nested_identifier]\n    by \n        name \nend rule\n\nrule replaceNewCall\n    replace [value]\n        'new class [class_name] '( vals [list value] ')\n    deconstruct class\n        id [id]\n    by\n        id '( vals ')\nend rule\n\nrule correctSuperInit\n    replace [nested_identifier]\n        'super( params [list value] ')\n    by\n        'super().__init__( params ')\nend rule\n\nrule correctSuperFunctions\n    replace [nested_identifier]\n        'super rep [repeat attribute_access]\n    by\n        'super() rep\nend rule\n\n%---------------------%\n% Boolean expressions %\n%---------------------%\n\nfunction replaceAllBoolean\n    replace [repeat statement]\n        statements [repeat statement]\n\n    by\n        statements\n            [replaceNullCheck]\n            [replaceNotNullCheck]\n            [replaceBoolNegation]\n            [replaceBoolAnd]\n            [replaceBoolOr]\n            [replaceTrue]\n            [replaceFalse]\n            [replaceClassMatchCheck]\nend function\n\nrule replaceNullCheck\n    replace [condition]\n        elem [value_no_recursion] '== 'null\n    by \n        elem 'is 'None\nend rule\n\nrule replaceNotNullCheck\n    replace [boolean_expression]\n        cond [condition]\n    deconstruct cond\n        elem [value_no_recursion] '!= 'null\n    by \n        'not '( elem 'is 'None ')\nend rule\n\nrule replaceBoolNegation\n    replace [value_no_recursion]\n        '! expr [boolean_expression]\n    by \n        'not expr\nend rule\n\nrule replaceBoolAnd\n    replace [boolean_operator]\n        '&&\n    by \n        'and\nend rule\n\nrule replaceBoolOr\n    replace [boolean_operator]\n        '|'|\n    by \n        'or\nend rule\n\nrule replaceTrue\n    replace [value]\n        'true\n    by \n        'True\nend rule\n\nrule replaceFalse\n    replace [value]\n        'false\n    by \n        'False\nend rule\n\nrule replaceClassMatchCheck\n    replace [boolean_expression]\n        'getClass().equals( id2 [id] '.getClass())\n    by  \n        'type(self) 'is 'type( id2 ')\nend rule\n\n\n";


		File txlFolder = new File("txl");
	    txlFolder.mkdirs();
	       
	    BufferedWriter bw = new BufferedWriter(new FileWriter(versionPath));
	    try {
	      bw.write(versionContent);
	      bw.flush();
	    } 
	    catch (Exception e) {
	      throw new UmpleCompilerException("An error occured while generating the TXL-Version.txt file.", e);
	    }
	    finally {
	      bw.close();
	    }	
	           
	    bw = new BufferedWriter(new FileWriter(javaGrmPath));
	    try {
	      bw.write(javaGrmContent);
	      bw.flush();
	    }  
	    catch (Exception e) {
	      throw new UmpleCompilerException("An error occured while generating the Java.Grm file.", e);
	    }
	    finally {
	      bw.close();
	    }
	    	       
	    bw = new BufferedWriter(new FileWriter(pythonGrmPath));
	    try {
	      bw.write(pythonGrmContent);
	      bw.flush();
	    }   
	    catch (Exception e) {
	      throw new UmpleCompilerException("An error occured while generating the Python.Grm file.", e);
	    }
	    finally {
	      bw.close();
	    }
	    	       
	    bw = new BufferedWriter(new FileWriter(txlTransPath));
	    try {
	      bw.write(umpleJavaToPythonTxlContent);
	      bw.flush();
	    }   
	    catch (Exception e) {
	      throw new UmpleCompilerException("An error occured while generating the umpleJavaToPython.txl file.", e);
	    }
	    finally {
	      bw.close();
	    }
	}
    
  }
  
}
